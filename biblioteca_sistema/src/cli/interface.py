import os
from colorama import Fore, Style, init
from tabulate import tabulate
from ..services.book_service import BookService
from ..services.user_service import UserService
from ..services.loan_service import LoanService


init()


class LibraryInterface:
    def __init__(self) -> None:
        self.book_service = BookService()
        self.user_service = UserService()
        self.loan_service = LoanService()

    def clear_screen(self) -> None:
        os.system('cls' if os.name == 'nt' else 'clear')

    def print_header(self, title: str) -> None:
        print(f"\n{Fore.CYAN}{'=' * 60}")
        print(f"{' ' * ((60 - len(title)) // 2)}{title}")
        print(f"{'=' * 60}{Style.RESET_ALL}\n")

    def print_success(self, message: str) -> None:
        print(f"{Fore.GREEN}‚úì {message}{Style.RESET_ALL}")

    def print_error(self, message: str) -> None:
        print(f"{Fore.RED}‚úó {message}{Style.RESET_ALL}")

    def print_warning(self, message: str) -> None:
        print(f"{Fore.YELLOW}‚ö† {message}{Style.RESET_ALL}")

    def wait_for_enter(self) -> None:
        input(f"\n{Fore.YELLOW}Pressione Enter para continuar...{Style.RESET_ALL}")

    def get_valid_integer(self, prompt: str, min_value: int | None = None, max_value: int | None = None) -> int:
        while True:
            try:
                value = int(input(prompt))
                if min_value is not None and value < min_value:
                    self.print_error(f"Valor deve ser maior ou igual a {min_value}")
                    continue
                if max_value is not None and value > max_value:
                    self.print_error(f"Valor deve ser menor ou igual a {max_value}")
                    continue
                return value
            except ValueError:
                self.print_error("Por favor, digite um n√∫mero v√°lido")

    def main_menu(self) -> None:
        while True:
            self.clear_screen()
            self.print_header("SISTEMA DE GERENCIAMENTO DE BIBLIOTECA")
            print(f"{Fore.YELLOW}1. üìö Gerenciar Livros")
            print(f"2. üë• Gerenciar Usu√°rios")
            print(f"3. üìñ Gerenciar Empr√©stimos")
            print(f"4. üìä Relat√≥rios")
            print(f"5. ‚ùå Sair{Style.RESET_ALL}")
            choice = input(f"\n{Fore.CYAN}Escolha uma op√ß√£o: {Style.RESET_ALL}")
            if choice == '1':
                self.books_menu()
            elif choice == '2':
                self.users_menu()
            elif choice == '3':
                self.loans_menu()
            elif choice == '4':
                self.reports_menu()
            elif choice == '5':
                self.print_success("Obrigado por usar o sistema!")
                break
            else:
                self.print_error("Op√ß√£o inv√°lida!")
                self.wait_for_enter()

    def books_menu(self) -> None:
        while True:
            self.clear_screen()
            self.print_header("GERENCIAR LIVROS")
            print(f"{Fore.YELLOW}1. ‚ûï Adicionar Livro")
            print(f"2. üìã Listar Livros")
            print(f"3. üîç Buscar Livros")
            print(f"4. üóëÔ∏è  Remover Livro")
            print(f"5. ‚¨ÖÔ∏è  Voltar{Style.RESET_ALL}")
            choice = input(f"\n{Fore.CYAN}Escolha uma op√ß√£o: {Style.RESET_ALL}")
            if choice == '1':
                self.add_book()
            elif choice == '2':
                self.list_books()
            elif choice == '3':
                self.search_books()
            elif choice == '4':
                self.remove_book()
            elif choice == '5':
                break
            else:
                self.print_error("Op√ß√£o inv√°lida!")
                self.wait_for_enter()

    def add_book(self) -> None:
        self.clear_screen()
        self.print_header("ADICIONAR LIVRO")
        try:
            title = input("T√≠tulo: ").strip()
            if not title:
                self.print_error("T√≠tulo n√£o pode estar vazio!")
                self.wait_for_enter()
                return
            author = input("Autor: ").strip()
            if not author:
                self.print_error("Autor n√£o pode estar vazio!")
                self.wait_for_enter()
                return
            year = self.get_valid_integer("Ano: ", 1000, 2025)
            category = input("Categoria: ").strip()
            if not category:
                self.print_error("Categoria n√£o pode estar vazia!")
                self.wait_for_enter()
                return
            book = self.book_service.add_book(title, author, year, category)
            self.print_success(f"Livro '{book.title}' adicionado com sucesso! (ID: {book.id})")
        except Exception as e:
            self.print_error(f"Erro ao adicionar livro: {str(e)}")
        self.wait_for_enter()

    def list_books(self) -> None:
        self.clear_screen()
        self.print_header("LISTA DE LIVROS")
        books = self.book_service.get_all_books()
        if not books:
            self.print_warning("Nenhum livro cadastrado")
        else:
            table_data = []
            for book in books:
                status = "‚úÖ Dispon√≠vel" if book.is_available else "‚ùå Emprestado"
                table_data.append([book.id, book.title, book.author, book.year, book.category, status])
            headers = ["ID", "T√≠tulo", "Autor", "Ano", "Categoria", "Status"]
            print(tabulate(table_data, headers=headers, tablefmt="grid"))
        self.wait_for_enter()

    def search_books(self) -> None:
        self.clear_screen()
        self.print_header("BUSCAR LIVROS")
        search_term = input("Digite o termo de busca (t√≠tulo ou autor): ").strip()
        if not search_term:
            self.print_error("Termo de busca n√£o pode estar vazio!")
            self.wait_for_enter()
            return
        books = self.book_service.search_books(search_term)
        if not books:
            self.print_warning("Nenhum livro encontrado")
        else:
            table_data = []
            for book in books:
                status = "‚úÖ Dispon√≠vel" if book.is_available else "‚ùå Emprestado"
                table_data.append([book.id, book.title, book.author, book.year, book.category, status])
            headers = ["ID", "T√≠tulo", "Autor", "Ano", "Categoria", "Status"]
            print(tabulate(table_data, headers=headers, tablefmt="grid"))
        self.wait_for_enter()

    def remove_book(self) -> None:
        self.clear_screen()
        self.print_header("REMOVER LIVRO")
        book_id = self.get_valid_integer("ID do livro a ser removido: ")
        book = self.book_service.get_book_by_id(book_id)
        if not book:
            self.print_error("Livro n√£o encontrado!")
            self.wait_for_enter()
            return
        print(f"\nLivro encontrado: {book.title} - {book.author}")
        confirm = input("Tem certeza que deseja remover? (s/N): ").lower()
        if confirm == 's':
            try:
                if self.book_service.delete_book(book_id):
                    self.print_success("Livro removido com sucesso!")
                else:
                    self.print_error("Erro ao remover livro")
            except Exception as e:
                self.print_error(f"Erro ao remover livro: {str(e)}")
        else:
            self.print_warning("Opera√ß√£o cancelada")
        self.wait_for_enter()

    def users_menu(self) -> None:
        while True:
            self.clear_screen()
            self.print_header("GERENCIAR USU√ÅRIOS")
            print(f"{Fore.YELLOW}1. ‚ûï Adicionar Usu√°rio")
            print(f"2. üìã Listar Usu√°rios")
            print(f"3. üîç Buscar Usu√°rios")
            print(f"4. ‚úèÔ∏è  Editar Usu√°rio")
            print(f"5. üóëÔ∏è  Remover Usu√°rio")
            print(f"6. ‚¨ÖÔ∏è  Voltar{Style.RESET_ALL}")
            choice = input(f"\n{Fore.CYAN}Escolha uma op√ß√£o: {Style.RESET_ALL}")
            if choice == '1':
                self.add_user()
            elif choice == '2':
                self.list_users()
            elif choice == '3':
                self.search_users()
            elif choice == '4':
                self.edit_user()
            elif choice == '5':
                self.remove_user()
            elif choice == '6':
                break
            else:
                self.print_error("Op√ß√£o inv√°lida!")
                self.wait_for_enter()

    def add_user(self) -> None:
        self.clear_screen()
        self.print_header("ADICIONAR USU√ÅRIO")
        try:
            name = input("Nome: ").strip()
            if not name:
                self.print_error("Nome n√£o pode estar vazio!")
                self.wait_for_enter()
                return
            email = input("Email: ").strip()
            if not email:
                self.print_error("Email n√£o pode estar vazio!")
                self.wait_for_enter()
                return
            phone = input("Telefone: ").strip()
            if not phone:
                self.print_error("Telefone n√£o pode estar vazio!")
                self.wait_for_enter()
                return
            user = self.user_service.add_user(name, email, phone)
            self.print_success(f"Usu√°rio '{user.name}' adicionado com sucesso! (ID: {user.id})")
        except ValueError as e:
            self.print_error(str(e))
        except Exception as e:
            self.print_error(f"Erro ao adicionar usu√°rio: {str(e)}")
        self.wait_for_enter()

    def list_users(self) -> None:
        self.clear_screen()
        self.print_header("LISTA DE USU√ÅRIOS")
        users = self.user_service.get_all_users()
        if not users:
            self.print_warning("Nenhum usu√°rio cadastrado")
        else:
            table_data = []
            for user in users:
                table_data.append([user.id, user.name, user.email, user.phone, user.created_at.strftime("%d/%m/%Y")])
            headers = ["ID", "Nome", "Email", "Telefone", "Cadastro"]
            print(tabulate(table_data, headers=headers, tablefmt="grid"))
        self.wait_for_enter()

    def search_users(self) -> None:
        self.clear_screen()
        self.print_header("BUSCAR USU√ÅRIOS")
        search_term = input("Digite o termo de busca (nome ou email): ").strip()
        if not search_term:
            self.print_error("Termo de busca n√£o pode estar vazio!")
            self.wait_for_enter()
            return
        users = self.user_service.search_users(search_term)
        if not users:
            self.print_warning("Nenhum usu√°rio encontrado")
        else:
            table_data = []
            for user in users:
                table_data.append([user.id, user.name, user.email, user.phone, user.created_at.strftime("%d/%m/%Y")])
            headers = ["ID", "Nome", "Email", "Telefone", "Cadastro"]
            print(tabulate(table_data, headers=headers, tablefmt="grid"))
        self.wait_for_enter()

    def edit_user(self) -> None:
        self.clear_screen()
        self.print_header("EDITAR USU√ÅRIO")
        user_id = self.get_valid_integer("ID do usu√°rio: ")
        user = self.user_service.get_user_by_id(user_id)
        if not user:
            self.print_error("Usu√°rio n√£o encontrado!")
            self.wait_for_enter()
            return
        print(f"\nUsu√°rio atual: {user.name} ({user.email})")
        print("Deixe em branco para manter o valor atual")
        try:
            name = input(f"Novo nome [{user.name}]: ").strip() or None
            email = input(f"Novo email [{user.email}]: ").strip() or None
            phone = input(f"Novo telefone [{user.phone}]: ").strip() or None
            if self.user_service.update_user(user_id, name, email, phone):
                self.print_success("Usu√°rio atualizado com sucesso!")
            else:
                self.print_error("Falha ao atualizar usu√°rio")
        except ValueError as e:
            self.print_error(str(e))
        self.wait_for_enter()

    def remove_user(self) -> None:
        self.clear_screen()
        self.print_header("REMOVER USU√ÅRIO")
        user_id = self.get_valid_integer("ID do usu√°rio a ser removido: ")
        user = self.user_service.get_user_by_id(user_id)
        if not user:
            self.print_error("Usu√°rio n√£o encontrado!")
            self.wait_for_enter()
            return
        print(f"\nUsu√°rio encontrado: {user.name} - {user.email}")
        confirm = input("Tem certeza que deseja remover? (s/N): ").lower()
        if confirm == 's':
            try:
                if self.user_service.delete_user(user_id):
                    self.print_success("Usu√°rio removido com sucesso!")
                else:
                    self.print_error("Erro ao remover usu√°rio")
            except Exception as e:
                self.print_error(f"Erro ao remover usu√°rio: {str(e)}")
        else:
            self.print_warning("Opera√ß√£o cancelada")
        self.wait_for_enter()

    def loans_menu(self) -> None:
        while True:
            self.clear_screen()
            self.print_header("GERENCIAR EMPR√âSTIMOS")
            print(f"{Fore.YELLOW}1. ‚ûï Criar Empr√©stimo")
            print(f"2. ‚Ü©Ô∏è  Devolver Empr√©stimo")
            print(f"3. üîÅ Renovar Empr√©stimo")
            print(f"4. üìã Listar Empr√©stimos Ativos")
            print(f"5. üïì Hist√≥rico de Empr√©stimos do Usu√°rio")
            print(f"6. ‚¨ÖÔ∏è  Voltar{Style.RESET_ALL}")
            choice = input(f"\n{Fore.CYAN}Escolha uma op√ß√£o: {Style.RESET_ALL}")
            if choice == '1':
                self.create_loan()
            elif choice == '2':
                self.return_loan()
            elif choice == '3':
                self.renew_loan()
            elif choice == '4':
                self.list_active_loans()
            elif choice == '5':
                self.user_loan_history()
            elif choice == '6':
                break
            else:
                self.print_error("Op√ß√£o inv√°lida!")
                self.wait_for_enter()

    def create_loan(self) -> None:
        self.clear_screen()
        self.print_header("CRIAR EMPR√âSTIMO")
        try:
            user_id = self.get_valid_integer("ID do usu√°rio: ")
            book_id = self.get_valid_integer("ID do livro: ")
            loan = self.loan_service.create_loan(user_id, book_id)
            self.print_success(f"Empr√©stimo criado! ID: {loan.id}")
        except Exception as e:
            self.print_error(str(e))
        self.wait_for_enter()

    def return_loan(self) -> None:
        self.clear_screen()
        self.print_header("DEVOLVER EMPR√âSTIMO")
        loan_id = self.get_valid_integer("ID do empr√©stimo: ")
        if self.loan_service.return_loan(loan_id):
            self.print_success("Empr√©stimo devolvido!")
        else:
            self.print_error("N√£o foi poss√≠vel devolver o empr√©stimo")
        self.wait_for_enter()

    def renew_loan(self) -> None:
        self.clear_screen()
        self.print_header("RENOVAR EMPR√âSTIMO")
        loan_id = self.get_valid_integer("ID do empr√©stimo: ")
        days = self.get_valid_integer("Dias de renova√ß√£o (padr√£o 7): ")
        if self.loan_service.renew_loan(loan_id, days):
            self.print_success("Empr√©stimo renovado!")
        else:
            self.print_error("N√£o foi poss√≠vel renovar o empr√©stimo")
        self.wait_for_enter()

    def list_active_loans(self) -> None:
        self.clear_screen()
        self.print_header("EMPR√âSTIMOS ATIVOS")
        loans = self.loan_service.get_active_loans()
        if not loans:
            self.print_warning("Nenhum empr√©stimo ativo")
        else:
            rows = []
            for loan in loans:
                rows.append([
                    loan.id,
                    loan.user_id,
                    loan.book_id,
                    loan.loan_date.strftime("%d/%m/%Y"),
                ])
            print(tabulate(rows, headers=["ID", "Usu√°rio", "Livro", "Data"], tablefmt="grid"))
        self.wait_for_enter()

    def user_loan_history(self) -> None:
        self.clear_screen()
        self.print_header("HIST√ìRICO DE EMPR√âSTIMOS DO USU√ÅRIO")
        user_id = self.get_valid_integer("ID do usu√°rio: ")
        loans = self.loan_service.get_user_history(user_id)
        if not loans:
            self.print_warning("Nenhum empr√©stimo encontrado")
        else:
            rows = []
            for loan in loans:
                rows.append([
                    loan.id,
                    loan.book_id,
                    loan.loan_date.strftime("%d/%m/%Y"),
                    loan.return_date.strftime("%d/%m/%Y") if loan.return_date else "-",
                    "Devolvido" if loan.is_returned else "Ativo",
                ])
            print(tabulate(rows, headers=["ID", "Livro", "Empr√©stimo", "Devolu√ß√£o", "Status"], tablefmt="grid"))
        self.wait_for_enter()

    def reports_menu(self) -> None:
        self.clear_screen()
        self.print_header("RELAT√ìRIOS")
        counts = self.book_service.get_books_count_by_status()
        print(f"Total: {counts['total']} | Dispon√≠veis: {counts['available']} | Emprestados: {counts['borrowed']}")
        by_category = self.book_service.get_books_count_by_category()
        if by_category:
            rows = [[cat, qty] for cat, qty in by_category.items()]
            print(tabulate(rows, headers=["Categoria", "Quantidade"], tablefmt="grid"))
        else:
            self.print_warning("Nenhum dado de categoria")
        self.wait_for_enter()


